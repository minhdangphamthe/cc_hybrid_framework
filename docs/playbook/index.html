<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hybrid Framework Playbook - Single-scene vs Multi-scene</title>
  <link rel="stylesheet" href="playbook.css" />
</head>
<body>
  <div class="layout">
    <aside class="sidebar">
      <div class="side-head">
        <div class="brand">
          <span>Hybrid Framework Playbook</span>
          <span class="pill">v0.1.2</span>
        </div>
        <div class="search">
          <input id="q" placeholder="Search... (e.g. persist, preload, fsm, mvvm)" />
        </div>
      </div>
      <nav class="nav" id="nav">
        <a href="#start" data-text="overview goals architecture"><strong>1) Getting started</strong><small>What this is and how to use it</small></a>
        <a href="#choose" data-text="choose mode single multi"><strong>2) Choose a mode</strong><small>When to use single vs multi</small></a>
        <a href="#single" data-text="single scene guide"><strong>3) Single-scene</strong><small>Flow, hierarchy, feature toggles</small></a>
        <a href="#multi" data-text="multi scene guide persist loadscene"><strong>4) Multi-scene</strong><small>Persistent core + scene loading</small></a>
        <a href="#unity" data-text="unity scenes additive"><strong>5) Unity habits</strong><small>What Unity teams usually do</small></a>
        <a href="#guardrails" data-text="guardrails conventions"><strong>6) Guardrails</strong><small>Rules that keep codebase healthy</small></a>
        <a href="#coding" data-text="coding standard formatting naming"><strong>7) Coding standard</strong><small>Formatting + naming conventions</small></a>
        <a href="#examples" data-text="code examples bootstrap appcontroller"><strong>8) Code examples</strong><small>Copy/paste friendly snippets</small></a>
        <a href="#checklist" data-text="shipping checklist"><strong>9) Shipping checklist</strong><small>Before you ship a build</small></a>
      </nav>
    </aside>

    <main class="main" id="main">
      <section id="start">
        <h1>Single-scene vs Multi-scene Playbook</h1>
        <p class="subtitle">
          Goal: help you pick the right scene mode for <b>hypercasual / casual / mid-core</b> games
          when porting from Unity to Cocos Creator 3.8.x, using the Hybrid Framework
          (Service Locator + FSM + MVVM-lite).
        </p>

        <div class="mode" id="modePicker">
          <span class="tag">View mode</span>
          <label><input type="radio" name="mode" value="single" checked /> Single-scene</label>
          <label><input type="radio" name="mode" value="multi" /> Multi-scene</label>
          <span class="pill">Switch any time</span>
        </div>

        <div class="two-col">
          <div class="card">
            <span class="tag good">Fast iteration</span>
            <span class="tag warn">Scale concerns</span>
            <span class="tag bad">Leaks if undisciplined</span>
            <p style="margin-top: 10px">
              <b>Single-scene</b> usually wins on speed and simplicity. <b>Multi-scene</b> usually wins on scale.
              This framework keeps the <b>core persistent</b>, so you can migrate between modes later.
            </p>
            <div class="callout warn">
              <div class="title"><span class="dot"></span>Remember</div>
              <div>
                In multi-scene mode, nodes inside a scene are destroyed when you load another scene.
                Keep your core on a <span class="kbd">Persist Root Node</span>.
              </div>
            </div>
          </div>

          <div class="diagram">
            <svg viewBox="0 0 840 380" width="100%" height="auto" role="img" aria-label="Architecture diagram">
              <defs>
                <linearGradient id="g1" x1="0" x2="1" y1="0" y2="1">
                  <stop offset="0" stop-color="rgba(125,211,252,0.35)"/>
                  <stop offset="1" stop-color="rgba(167,139,250,0.25)"/>
                </linearGradient>
                <linearGradient id="g2" x1="0" x2="1" y1="0" y2="1">
                  <stop offset="0" stop-color="rgba(52,211,153,0.22)"/>
                  <stop offset="1" stop-color="rgba(125,211,252,0.16)"/>
                </linearGradient>
              </defs>
              <rect x="16" y="16" width="808" height="348" rx="18" fill="rgba(0,0,0,0.18)" stroke="rgba(255,255,255,0.10)"/>
              <text x="36" y="54" fill="rgba(230,233,242,0.9)" font-size="18" font-family="system-ui">Hybrid Architecture</text>

              <rect x="36" y="76" width="250" height="120" rx="14" fill="url(#g1)" stroke="rgba(255,255,255,0.10)"/>
              <text x="56" y="108" fill="#e6e9f2" font-size="14" font-family="system-ui" font-weight="700">Core (Persistent)</text>
              <text x="56" y="132" fill="rgba(230,233,242,0.85)" font-size="12" font-family="system-ui">ServiceLocator</text>
              <text x="56" y="152" fill="rgba(230,233,242,0.85)" font-size="12" font-family="system-ui">EventBus - Lifetime</text>
              <text x="56" y="172" fill="rgba(230,233,242,0.85)" font-size="12" font-family="system-ui">AppController (App FSM)</text>

              <rect x="310" y="76" width="250" height="120" rx="14" fill="rgba(255,255,255,0.04)" stroke="rgba(255,255,255,0.10)"/>
              <text x="330" y="108" fill="#e6e9f2" font-size="14" font-family="system-ui" font-weight="700">Services</text>
              <text x="330" y="132" fill="rgba(230,233,242,0.85)" font-size="12" font-family="system-ui">Assets - Audio - Save - Network</text>
              <text x="330" y="152" fill="rgba(230,233,242,0.85)" font-size="12" font-family="system-ui">Ads - Analytics - Push - Scene</text>
              <text x="330" y="172" fill="rgba(230,233,242,0.85)" font-size="12" font-family="system-ui">Time - Input</text>

              <rect x="584" y="76" width="220" height="120" rx="14" fill="url(#g2)" stroke="rgba(255,255,255,0.10)"/>
              <text x="604" y="108" fill="#e6e9f2" font-size="14" font-family="system-ui" font-weight="700">Feature Layer</text>
              <text x="604" y="132" fill="rgba(230,233,242,0.85)" font-size="12" font-family="system-ui">Home / Shop / Gameplay</text>
              <text x="604" y="152" fill="rgba(230,233,242,0.85)" font-size="12" font-family="system-ui">UI MVVM-lite</text>
              <text x="604" y="172" fill="rgba(230,233,242,0.85)" font-size="12" font-family="system-ui">InGame FSM - Pooling</text>

              <path d="M286 136 L310 136" stroke="rgba(255,255,255,0.28)" stroke-width="2" />
              <path d="M560 136 L584 136" stroke="rgba(255,255,255,0.28)" stroke-width="2" />
              <text x="36" y="238" fill="rgba(230,233,242,0.9)" font-size="13" font-family="system-ui" font-weight="700">Key idea</text>
              <text x="36" y="264" fill="rgba(230,233,242,0.75)" font-size="12" font-family="system-ui">
                Core survives scene changes. Features can be nodes (single-scene) or scenes (multi-scene).
              </text>
            </svg>
          </div>
        </div>
      </section>

      <section id="choose">
        <h2>2) Choose a mode</h2>
        <div class="grid">
          <div class="card">
            <h3>Single-scene</h3>
            <span class="tag good">Fast</span>
            <span class="tag good">Less hitch</span>
            <span class="tag warn">Scene can bloat</span>
            <ul>
              <li>Best for hypercasual and smaller casual games.</li>
              <li>Great for web / low-end devices because you avoid loadScene hitches.</li>
              <li>Use FSM to toggle feature root nodes and popups.</li>
            </ul>
          </div>
          <div class="card">
            <h3>Multi-scene</h3>
            <span class="tag good">Scales well</span>
            <span class="tag warn">Needs preload discipline</span>
            <span class="tag warn">Persistence required</span>
            <ul>
              <li>Best for bigger casual / mid-core: Home + Shop + Inventory + Gameplay.</li>
              <li>Easy to split work across teams and unload scene-local objects.</li>
              <li>Requires a scene loading flow and an asset strategy.</li>
            </ul>
          </div>
        </div>

        <div class="callout good">
          <div class="title"><span class="dot"></span>Recommendation</div>
          <div>
            If you need speed while porting from Unity, start with single-scene.
            When your feature set grows, switch to multi-scene (the persistent core stays the same).
          </div>
        </div>
      </section>

      <section id="single" class="mode-only show-single">
        <h2>3) Single-scene guide</h2>
        <p>
          A single scene (e.g. <b>Main</b>) contains Home UI, gameplay objects, and result popups.
          AppFlow transitions are implemented by <b>enabling/disabling feature root nodes</b>.
        </p>

        <div class="callout warn">
          <div class="title"><span class="dot"></span>Critical rule</div>
          <div>
            Avoid sprinkling <span class="kbd">update()</span> everywhere.
            Centralize ticking in a controller/system runner. Pooling must clean up tweens/timers/listeners on despawn.
          </div>
        </div>

        <details>
          <summary>Recommended hierarchy</summary>
          <div class="grid">
            <div class="card">
              <strong>Hierarchy</strong>
              <pre><code class="language-ts">MainScene
-  Framework (persistent)
    -  FrameworkBootstrap
    -  AppController
-  FeatureRoot
    -  HomeRoot (UI)
    -  GameplayRoot (world)
    -  ResultRoot (UI)
-  UIRoot</code></pre>
            </div>
            <div class="card">
              <strong>Flow</strong>
              <ul>
                <li>AppController emits <span class="kbd">app/stateChanged</span></li>
                <li>HomeRoot listens and emits <span class="kbd">app/play</span> when user taps Play</li>
                <li>GameplayRoot listens and emits <span class="kbd">app/restart</span> or <span class="kbd">app/backToHome</span></li>
              </ul>
            </div>
          </div>
        </details>
      </section>

      <section id="multi" class="mode-only show-multi">
        <h2>4) Multi-scene guide</h2>
        <p>
          Multi-scene splits your game into scenes: <b>Boot</b>, <b>Home</b>, <b>Gameplay</b>, (optional) <b>Result</b>.
          The core (Bootstrap + services + AppController) stays on a persistent node.
        </p>

        <div class="callout warn">
          <div class="title"><span class="dot"></span>Persistence is required</div>
          <div>
            Without persistence, you lose ServiceLocator/EventBus/global state every time you load a scene.
            FrameworkBootstrap already calls <span class="kbd">director.addPersistRootNode()</span> by default.
          </div>
        </div>

        <details>
          <summary>Recommended scene list</summary>
          <pre><code class="language-ts">Scenes
- Boot.scene (only Framework node)
- Home.scene (Home UI emits app/play)
- Gameplay.scene (GameplayController emits app/restart/app/backToHome)
- Result.scene (optional)</code></pre>
        </details>

        <details>
          <summary>Preload & loading (practical tips)</summary>
          <ul>
            <li>Use <span class="kbd">ISceneService.preloadScene</span> to get progress.</li>
            <li>Loading UI can be a persistent overlay or part of the Boot scene.</li>
            <li>Preload bundles per feature: core in Boot, gameplay bundle when entering Gameplay.</li>
          </ul>
        </details>
      </section>

      <section id="unity">
        <h2>5) Unity habits</h2>
        <div class="grid">
          <div class="card">
            <h3>What Unity teams often do</h3>
            <ul>
              <li>Hypercasual: frequently <b>single-scene + managers/FSM</b>.</li>
              <li>Casual/Mid-core: often <b>multi-scene</b> or <b>hybrid</b> (persistent core + additive scenes).</li>
              <li>Additive scenes are commonly used to separate UI, lighting, and level content.</li>
            </ul>
          </div>
          <div class="card">
            <h3>When porting to Cocos</h3>
            <ul>
              <li>Single-scene tends to feel smoother on web/low-end devices.</li>
              <li>Multi-scene requires stronger preload discipline to avoid hitching.</li>
              <li>Keep gameplay logic engine-agnostic via service interfaces.</li>
            </ul>
          </div>
        </div>
      </section>

      <section id="guardrails">
        <h2>6) Guardrails</h2>
        <div class="grid">
          <div class="card">
            <h3>Gameplay must not call UI directly</h3>
            <p>Gameplay emits events. UI subscribes and renders.</p>
          </div>
          <div class="card">
            <h3>Services must not import game code</h3>
            <p>Infrastructure only. Game/feature code depends on services, not the other way around.</p>
          </div>
          <div class="card">
            <h3>Pooling must clean up</h3>
            <p>Despawn = stop tweens/timers/listeners + reset state. Use IPoolable.</p>
          </div>
          <div class="card">
            <h3>Only one AppController</h3>
            <p>AppFlow FSM lives in a single place. Avoid multiple managers fighting each other.</p>
          </div>
        </div>
      </section>

      <section id="coding">
        <h2>7) Coding standard</h2>
        <div class="card">
          <div class="markdown">## Coding standard (project-wide)

Formatting
- Indentation: **2 spaces**, no tabs.
- Quotes: **single quotes** for strings.
- Semicolons: **required**.
- Spacing:
  - `if (cond) { ... }` (space after keywords, space before `{`)
  - `{ a: 1, b: 2 }` (spaces inside object braces)
  - `fn(a, b)` (space after commas)
- Trailing commas: **recommended** for multi-line objects/arrays.

Naming
- Files:
  - Components / Services: `PascalCase.ts` (e.g. `AppController.ts`).
  - Interfaces: `IThing.ts` (e.g. `IAudioService.ts`).
- Types/classes/enums: `PascalCase`.
- Methods/functions/variables: `camelCase`.
- Private fields: `private _likeThis` (leading underscore).
- Public fields: no underscore.
- Constants: `UPPER_SNAKE_CASE` (rare; prefer `const` at module scope when needed).

Comments
- English only.
- Explain **why** (intent/constraints), not the obvious &quot;what&quot;.
</div>
        </div>
      </section>

      <section id="examples">
        <h2>8) Code examples</h2>

        <details open>
          <summary>FrameworkBootstrap (v0.1.2) - persistent core + auto AppController</summary>
          <pre><code class="language-ts">import { _decorator, Component, director } from 'cc';
import { ServiceLocator } from './core/ServiceLocator';
import { EventBus } from './core/EventBus';
import { Services } from './services/ServiceTokens';
import { CocosSceneService } from './services/impl/CocosSceneService';
import { AppController } from './app/AppController';
import { AppSceneMode, type AppSceneModeName } from './app/AppConstants';

@ccclass('FrameworkBootstrap')
export class FrameworkBootstrap extends Component {
  persistAcrossScenes = true;
  autoAddAppController = true;
  sceneMode: AppSceneModeName = AppSceneMode.Single;

  onLoad(): void {
    if (this.persistAcrossScenes) {
      director.addPersistRootNode(this.node);
    }

    // Use Services tokens instead of magic strings
    ServiceLocator.register(Services.EventBus, new EventBus&lt;any&gt;());
    ServiceLocator.register(Services.Scene, new CocosSceneService());

    if (this.autoAddAppController) {
      const app = this.getComponent(AppController) ?? this.addComponent(AppController);
      app.configure({ mode: this.sceneMode });
    }
  }
}</code></pre>
        </details>

        <details>
          <summary>Home UI: emit app/play</summary>
          <pre><code class="language-ts">import { _decorator, Component } from 'cc';
import { ServiceLocator } from '../framework/core/ServiceLocator';
import { EventBus } from '../framework/core/EventBus';
import { Services } from '../framework/services/ServiceTokens';
import { AppEvents } from '../framework/app/AppEvents';
import { AppEvent } from '../framework/app/AppConstants';

@ccclass('HomeView')
export class HomeView extends Component {
  private _bus!: EventBus&lt;AppEvents&gt;;

  onLoad(): void {
    this._bus = ServiceLocator.resolve&lt;EventBus&lt;AppEvents&gt;&gt;(Services.EventBus);
  }

  onClickPlay(): void {
    this._bus.emit(AppEvent.Play, {});
  }
}</code></pre>
        </details>

        <details>
          <summary>Gameplay: restart or go back home</summary>
          <pre><code class="language-ts">import { _decorator, Component } from 'cc';
import { ServiceLocator } from '../framework/core/ServiceLocator';
import { EventBus } from '../framework/core/EventBus';
import { Services } from '../framework/services/ServiceTokens';
import { AppEvents } from '../framework/app/AppEvents';
import { AppEvent } from '../framework/app/AppConstants';

@ccclass('GameplayController')
export class GameplayController extends Component {
  private _bus!: EventBus&lt;AppEvents&gt;;

  onLoad(): void {
    this._bus = ServiceLocator.resolve&lt;EventBus&lt;AppEvents&gt;&gt;(Services.EventBus);
  }

  onUserDie(): void {
    this._bus.emit(AppEvent.Restart, {});
  }

  onUserBackHome(): void {
    this._bus.emit(AppEvent.BackToHome, {});
  }
}</code></pre>
        </details>
      </section>

      <section id="checklist">
        <h2>9) Shipping checklist</h2>
        <div class="grid">
          <div class="card">
            <h3>Performance</h3>
            <ul>
              <li>Centralize update loops; avoid hundreds of component updates per frame.</li>
              <li>Pool frequently spawned prefabs.</li>
              <li>Preload bundles per feature/scene.</li>
            </ul>
          </div>
          <div class="card">
            <h3>Stability</h3>
            <ul>
              <li>Own EventBus subscriptions via lifetime/disposables.</li>
              <li>Guard async loads when the scene changes.</li>
              <li>Persistent node should only keep core systems, not scene objects.</li>
            </ul>
          </div>
          <div class="card">
            <h3>Meta-game</h3>
            <ul>
              <li>Use MVVM-lite for HUD/popup logic.</li>
              <li>Keep theme/skin data-driven (avoid hardcoded asset references in VM).</li>
            </ul>
          </div>
          <div class="card">
            <h3>Unity porting</h3>
            <ul>
              <li>Keep domain logic in pure TypeScript (no engine dependency).</li>
              <li>Map Unity systems to service interfaces.</li>
              <li>Prefer composition over deep inheritance.</li>
            </ul>
          </div>
        </div>
      </section>
    </main>
  </div>

  
  

  <script src="playbook.js"></script>
</body>
</html>
